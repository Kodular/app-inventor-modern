// -*- mode: java; c-basic-offset: 2; -*-
// Copyright 2009-2011 Google, All Rights reserved
// Copyright 2011-2021 MIT, All rights reserved
// Released under the Apache License, Version 2.0
// http://www.apache.org/licenses/LICENSE-2.0
package com.google.appinventor.buildserver

import com.google.appinventor.common.version.GitBuildId
import java.io.ByteArrayOutputStream
import java.io.*
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream

/**
 * Top level class for exposing the building of App Inventor APK files as a RESTful web service.
 *
 * Note that these BuildServer objects are created per request
 *
 * @author markf@google.com (Mark Friedman)
 */
// The Java class will be hosted at the URI path "/buildserver"
@Path("/buildserver")
class BuildServer {
    private val projectBuilder: ProjectBuilder = ProjectBuilder()

    class ProgressReporter(  // We create a ProgressReporter instance which is handed off to the
        // project builder and compiler. It is called to report the progress
        // of the build. The reporting is done by calling the callback URL
        // and putting the status inside a "build.status" file. This isn't
        // particularly efficient, but this is the version 0.9 implementation
        var callbackUrlStr: String
    ) {
        fun report(progress: Int) {
            try {
                val output = ByteArrayOutputStream()
                val zipoutput = ZipOutputStream(output)
                zipoutput.putNextEntry(ZipEntry("build.status"))
                val pout = PrintWriter(zipoutput)
                pout.println(progress)
                pout.flush()
                zipoutput.flush()
                zipoutput.close()
                val zipinput = ByteArrayInputStream(output.toByteArray())
                val callbackUrl = URL(callbackUrlStr)
                val connection: HttpURLConnection = callbackUrl.openConnection() as HttpURLConnection
                connection.setDoOutput(true)
                connection.setRequestMethod("POST")
                // Make sure we aren't misinterpreted as
                // form-url-encoded
                connection.addRequestProperty("Content-Type", "application/zip; charset=utf-8")
                connection.setConnectTimeout(5000)
                connection.setReadTimeout(5000)
                val bufferedOutputStream = BufferedOutputStream(connection.getOutputStream())
                try {
                    val bufferedInputStream = BufferedInputStream(zipinput)
                    try {
                        ByteStreams.copy(bufferedInputStream, bufferedOutputStream)
                        bufferedOutputStream.flush()
                    } finally {
                        bufferedInputStream.close()
                    }
                } finally {
                    bufferedOutputStream.close()
                }
                if (connection.getResponseCode() !== HttpURLConnection.HTTP_OK) {
                    LOG.severe("Bad Response Code! (sending status): " + connection.getResponseCode())
                }
            } catch (e: IOException) {
                LOG.severe("IOException during progress report!")
            }
        }
    }

    internal class CommandLineOptions {
        @Option(name = "--shutdownToken", usage = "Token needed to shutdown the server remotely.")
        var shutdownToken: String? = null

        @Option(name = "--childProcessRamMb", usage = "Maximum ram that can be used by a child processes, in MB.")
        var childProcessRamMb = 2048

        @Option(
            name = "--maxSimultaneousBuilds",
            usage = "Maximum number of builds that can run in parallel. O means unlimited."
        )
        var maxSimultaneousBuilds = 0 // The default is unlimited.

        @Option(name = "--port", usage = "The port number to bind to on the local machine.")
        var port = 9990

        @Option(
            name = "--requiredHosts",
            usage = "If specified, a list of hosts which are permitted to use this BuildServer, other the server is open to all.",
            handler = StringArrayOptionHandler::class
        )
        var requiredHosts: Array<String>? = null

        @Option(name = "--debug", usage = "Turn on debugging, which enables the non-async calls of the buildserver.")
        var debug = false

        @Option(name = "--dexCacheDir", usage = "the directory to cache the pre-dexed libraries")
        var dexCacheDir: String? = null
    }

    // The input zip file. It will be deleted in cleanUp.
    private var inputZip: File? = null

    // The built APK file for this build request, if any.
    private var outputApk: File? = null

    // The temp directory that we're building in.
    private var outputDir: File? = null

    // The android.keystore file generated by this build request, if necessary.
    private var outputKeystore: File? = null

    // The zip file where we put all the build results for this request.
    private var outputZip: File? = null

    // ShutdownState: UP:         We are up and running
    //                SHUTTING:   We have been told to shutdown, with a time delay
    //                            In this state we return bad health, but accept jobs
    //                DOWN:       We return bad health and reject jobs
    //                DRAINING:   We have reached > 2/3 of max permitted jobs
    //                            We return bad health (but accept jobs) until
    //                            the number of active jobs is < 1/3 of max
    private enum class ShutdownState {
        UP, SHUTTING, TURNING, DOWN, DRAINING
    }

    // the load to become < 1/3 max load
    @GET
    @Path("health")
    @Produces(MediaType.TEXT_PLAIN)
    @Throws(IOException::class)
    fun health(): Response {
        val shut = shutdownState
        return when (shut) {
            ShutdownState.UP -> {
                LOG.info("Healthcheck: UP")
                Response.ok("ok", MediaType.TEXT_PLAIN_TYPE).build()
            }
            ShutdownState.DOWN -> {
                LOG.info("Healthcheck: DOWN")
                Response.status(Response.Status.FORBIDDEN).type(MediaType.TEXT_PLAIN_TYPE)
                    .entity("Build Server is shutdown")
                    .build()
            }
            ShutdownState.DRAINING -> {
                LOG.info("Healthcheck: DRAINING")
                Response.status(Response.Status.FORBIDDEN).type(MediaType.TEXT_PLAIN_TYPE)
                    .entity("Build Server is draining")
                    .build()
            }
            ShutdownState.TURNING -> {
                LOG.info("Healthcheck: TURNING")
                Response.status(Response.Status.FORBIDDEN).type(MediaType.TEXT_PLAIN_TYPE)
                    .entity("Build Server is turning on")
                    .build()
            }
            else -> {
                LOG.info("Healthcheck: SHUTTING")
                Response.status(Response.Status.FORBIDDEN).type(MediaType.TEXT_PLAIN_TYPE)
                    .entity("Build Server is shutting down").build()
            }
        }
    }

    @GET
    @Path("vars")
    @Produces(MediaType.TEXT_HTML)
    @Throws(IOException::class)
    fun `var`(): Response {
        val variables: Map<String, String> = LinkedHashMap<String, String>()

        // Runtime
        val runtimeBean: RuntimeMXBean = ManagementFactory.getRuntimeMXBean()
        val dateTimeFormat: DateFormat = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.FULL)
        variables.put("state", shutdownState.toString() + "")
        if (shuttingTime != 0L) {
            variables.put("shutdown-time", dateTimeFormat.format(Date(shuttingTime)))
        }
        if (turningOnTime != 0L) {
            variables.put("turnon-time", dateTimeFormat.format(Date(turningOnTime)))
        }
        variables.put("start-time", dateTimeFormat.format(Date(runtimeBean.getStartTime())))
        variables.put("uptime-in-ms", runtimeBean.getUptime().toString() + "")
        variables.put("vm-name", runtimeBean.getVmName())
        variables.put("vm-vender", runtimeBean.getVmVendor())
        variables.put("vm-version", runtimeBean.getVmVersion())

        //BuildServer Version and Id
        variables.put("buildserver-version", GitBuildId.getVersion().toString() + "")
        variables.put("buildserver-git-fingerprint", GitBuildId.getFingerprint().toString() + "")

        // OS
        val osBean: OperatingSystemMXBean = ManagementFactory.getOperatingSystemMXBean()
        variables.put("os-arch", osBean.getArch())
        variables.put("os-name", osBean.getName())
        variables.put("os-version", osBean.getVersion())
        variables.put("num-processors", osBean.getAvailableProcessors().toString() + "")
        variables.put("load-average-past-1-min", osBean.getSystemLoadAverage().toString() + "")

        // Threads
        variables.put("num-java-threads", ManagementFactory.getThreadMXBean().getThreadCount().toString() + "")

        // Memory
        val runtime: Runtime = Runtime.getRuntime()
        val memoryBean: MemoryMXBean = ManagementFactory.getMemoryMXBean()
        variables.put("total-memory", runtime.totalMemory().toString() + "")
        variables.put("free-memory", runtime.freeMemory().toString() + "")
        variables.put("max-memory", runtime.maxMemory().toString() + "")
        variables.put("used-heap", memoryBean.getHeapMemoryUsage().getUsed().toString() + "")
        variables.put("used-non-heap", memoryBean.getNonHeapMemoryUsage().getUsed().toString() + "")

        // Build requests
        variables.put("count-async-build-requests", asyncBuildRequests.get().toString() + "")
        variables.put("rejected-async-build-requests", rejectedAsyncBuildRequests.get().toString() + "")
        variables.put("successful-async-build-requests", successfulBuildRequests.get().toString() + "")
        variables.put("failed-async-build-requests", failedBuildRequests.get().toString() + "")

        // Build tasks
        val max: Int = buildExecutor.getMaxActiveTasks()
        if (max == 0) {
            variables.put("maximum-simultaneous-build-tasks-allowed", "unlimited")
        } else {
            variables.put("maximum-simultaneous-build-tasks-allowed", max.toString() + "")
        }
        variables.put("completed-build-tasks", buildExecutor!!.getCompletedTaskCount().toString() + "")
        maximumActiveBuildTasks = Math.max(maximumActiveBuildTasks, buildExecutor!!.getActiveTaskCount())
        variables.put("maximum-simultaneous-build-tasks-occurred", maximumActiveBuildTasks.toString() + "")
        variables.put("active-build-tasks", buildExecutor!!.getActiveTaskCount().toString() + "")
        val html = StringBuilder()
        html.append("<html><body><tt>")
        for (variable in variables.entrySet()) {
            html.append("<b>").append(variable.getKey()).append("</b> ")
                .append(variable.getValue()).append("<br>")
        }
        html.append("</tt></body></html>")
        return Response.ok(html.toString(), MediaType.TEXT_HTML_TYPE).build()
    }

    /**
     * Indicate that the server is shutting down.
     *
     * @param token -- secret token used like a password to authenticate the shutdown command
     * @param delay -- the delay in seconds before jobs are no longer accepted
     */
    @GET
    @Path("shutdown")
    @Produces(MediaType.TEXT_PLAIN)
    @Throws(IOException::class)
    fun shutdown(@QueryParam("token") token: String?, @QueryParam("delay") delay: String?): Response {
        return if (commandLineOptions.shutdownToken == null || token == null) {
            Response.status(Response.Status.FORBIDDEN).type(MediaType.TEXT_PLAIN_TYPE).entity("No Shutdown Token")
                .build()
        } else if (!token.equals(commandLineOptions.shutdownToken)) {
            Response.status(Response.Status.FORBIDDEN).type(MediaType.TEXT_PLAIN_TYPE).entity("Invalid Shutdown Token")
                .build()
        } else {
            var shutdownTime: Long = System.currentTimeMillis()
            if (delay != null) {
                try {
                    shutdownTime += Integer.parseInt(delay) * 1000
                } catch (e: NumberFormatException) {
                    // XXX Ignore
                }
            }
            shuttingTime = shutdownTime
            val dateTimeFormat: DateFormat = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.FULL)
            Response.ok(
                "ok: Will shutdown at " + dateTimeFormat.format(Date(shuttingTime)),
                MediaType.TEXT_PLAIN_TYPE
            ).build()
        }
    }

    /**
     * Indicate that the server is turning on.
     *
     * @param token -- secret token used like a password to authenticate the shutdown command
     * @param delay -- the delay in seconds before jobs are no longer accepted
     */
    @GET
    @Path("turnon")
    @Produces(MediaType.TEXT_PLAIN)
    @Throws(IOException::class)
    fun turnon(@QueryParam("token") token: String?, @QueryParam("delay") delay: String?): Response {
        return if (commandLineOptions.shutdownToken == null || token == null) {
            Response.status(Response.Status.FORBIDDEN).type(MediaType.TEXT_PLAIN_TYPE).entity("No Shutdown Token")
                .build()
        } else if (!token.equals(commandLineOptions.shutdownToken)) {
            Response.status(Response.Status.FORBIDDEN).type(MediaType.TEXT_PLAIN_TYPE).entity("Invalid Shutdown Token")
                .build()
        } else {
            if (shuttingTime == 0L) {
                return Response.status(Response.Status.FORBIDDEN).type(MediaType.TEXT_PLAIN_TYPE)
                    .entity("Buildserver is not expected to be shutted down").build()
            }
            var turnonTime: Long = System.currentTimeMillis()
            if (delay != null) {
                try {
                    turnonTime += Integer.parseInt(delay) * 1000
                } catch (e: NumberFormatException) {
                    // XXX Ignore
                }
            }
            turningOnTime = turnonTime
            val dateTimeFormat: DateFormat = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.FULL)
            Response.ok(
                "ok: Will turnon at " + dateTimeFormat.format(Date(turningOnTime)),
                MediaType.TEXT_PLAIN_TYPE
            ).build()
        }
    }

    /**
     * Build an APK file from the input zip file. The zip file needs to be a variant of the same
     * App Inventor source zip that's generated by the Download Source command.  The differences are
     * that it might not contain a .yail file (in which case we will generate the YAIL code) and it
     * might contain an android.keystore file at the top level (in which case we will use it to sign
     * the APK.  If there is no android.keystore file in the zip we will generate one.
     *
     * @param userName  The user name to be used in making the CN entry in the generated keystore
     * @param zipFile
     * @return the APK file
     */
    @POST
    @Path("build-from-zip")
    @Produces("application/vnd.android.package-archive;charset=utf-8")
    @Throws(IOException::class)
    fun buildFromZipFile(
        @QueryParam("uname") userName: String,
        @QueryParam("ext") ext: String?,
        zipFile: File?
    ): Response {
        // Set the inputZip field so we can delete the input zip file later in cleanUp.
        inputZip = zipFile
        inputZip.deleteOnExit() // In case build server is killed before cleanUp executes.
        if (!commandLineOptions.debug) return Response.status(Response.Status.FORBIDDEN).type(MediaType.TEXT_PLAIN_TYPE)
            .entity("Entry point unavailable unless debugging.").build()
        val isAab: Boolean = constants.AAB_EXTENSION_VALUE.equals(ext)
        return try {
            build(userName, zipFile, isAab, null)
            val attachedFilename: String = outputApk.getName()
            val outputApkDeleteOnClose: FileInputStream =
                DeleteFileOnCloseFileInputStream(outputApk)
            // Set the outputApk field to null so that it won't be deleted in cleanUp().
            outputApk = null
            Response.ok(outputApkDeleteOnClose)
                .header("Content-Disposition", "attachment; filename=\"$attachedFilename\"")
                .build()
        } finally {
            cleanUp()
        }
    }

    /**
     * Build an APK file from the input zip file. The zip file needs to be a variant of the same
     * App Inventor source zip that's generated by the Download Source command.  The differences are
     * that it might not contain a .yail file (in which case we will generate the YAIL code) and it
     * might contain an android.keystore file at the top level (in which case we will use it to sign
     * the APK.  If there is no android.keystore file in the zip we will generate one and return it
     * in along with the APK file.
     *
     * We'll respond to the requester with a zip file containing the build.out and build.err files as
     * well as the APK file if the build succeeded and the android.keystore file if it was not
     * provided in the input zip
     *
     * @param userName  The user name to be used in making the CN entry in the generated keystore
     * @param inputZipFile  The zip file representing the App Inventor source code.
     * @return an "OK" [Response].
     */
    @POST
    @Path("build-all-from-zip")
    @Produces("application/zip;charset=utf-8")
    @Throws(IOException::class, JSONException::class)
    fun buildAllFromZipFile(
        @QueryParam("uname") userName: String,
        @QueryParam("ext") ext: String?,
        inputZipFile: File
    ): Response {
        // Set the inputZip field so we can delete the input zip file later in cleanUp.
        inputZip = inputZipFile
        inputZip.deleteOnExit() // In case build server is killed before cleanUp executes.
        if (!commandLineOptions.debug) return Response.status(Response.Status.FORBIDDEN).type(MediaType.TEXT_PLAIN_TYPE)
            .entity("Entry point unavailable unless debugging.").build()
        val isAab: Boolean = Main.AAB_EXTENSION_VALUE.equals(ext)
        return try {
            buildAndCreateZip(userName, inputZipFile, isAab, null)
            val attachedFilename: String = outputZip.getName()
            val outputZipDeleteOnClose: FileInputStream =
                DeleteFileOnCloseFileInputStream(outputZip)
            // Set the outputZip field to null so that it won't be deleted in cleanUp().
            outputZip = null
            Response.ok(outputZipDeleteOnClose)
                .header("Content-Disposition", "attachment; filename=\"$attachedFilename\"")
                .build()
        } finally {
            cleanUp()
        }
    }

    /**
     * Asynchronously build an APK file from the input zip file and then send it to the callbackUrl.
     * The input zip file needs to be a variant of the same App Inventor source zip that's generated
     * by the Download Source command.  The differences are that it might not contain a .yail file (in
     * which case we will generate the YAIL code) and it might contain an android.keystore file at the
     * top level (in which case we will use it to sign the APK).
     *
     * We'll use the callbackUrlStr to post back a zip file containing the build.out and build.err
     * files as well as the APK file if the build succeeded and the android.keystore file if it was
     * not provided in the input zip
     *
     * Before building the app, we'll check that the gitBuildVersion parameter (if present) equals
     * GitBuildId.getVersion(). If the values are different, we won't even try to build
     * the app. This may seem too strict, but we need to make sure that when we build apps, we use
     * the same version of the code that loads the .blk and .scm files, the same version of
     * runtime.scm, and the same version of the App Inventor component classes.
     *
     * The status code returned here will be seen by the server in YoungAndroidProjectService.build
     * as connection.getResponseCode().
     *
     * @param userName  The user name to be used in making the CN entry in the generated keystore.
     * @param gitBuildVersion  The value of GitBuildId.getVersion() sent from
     * YoungAndroidProjectService.build.
     * @param callbackUrlStr An url to send the build results back to.
     * @param inputZipFile  The zip file representing the App Inventor source code.
     * @return a status response, typically OK (200) or SERVICE_UNAVAILABLE (503).
     */
    @POST
    @Path("build-all-from-zip-async")
    @Produces(MediaType.TEXT_PLAIN)
    @Throws(IOException::class)
    fun buildAllFromZipFileAsync(
        @QueryParam("uname") userName: String,
        @QueryParam("callback") callbackUrlStr: String,
        @QueryParam("gitBuildVersion") gitBuildVersion: String?,
        @QueryParam("ext") ext: String?,
        inputZipFile: File
    ): Response {
        // Set the inputZip field so we can delete the input zip file later in
        // cleanUp.
        inputZip = inputZipFile
        inputZip.deleteOnExit() // In case build server is killed before cleanUp executes.
        val requesting_host: String = URL(callbackUrlStr).getHost()
        val isAab: Boolean = Main.AAB_EXTENSION_VALUE.equals(ext)

        //for the request for update part, the file should be empty
        if (inputZip.length() === 0L) {
            cleanUp()
        } else {
            if (shutdownState == ShutdownState.DOWN) {
                LOG.info("request received while shutdown completely")
                return Response.status(Response.Status.FORBIDDEN).type(MediaType.TEXT_PLAIN_TYPE)
                    .entity("Temporary build error, try again.").build()
            }
            if (commandLineOptions.requiredHosts != null) {
                var oktoproceed = false
                for (host in commandLineOptions.requiredHosts!!) {
                    if (host.equals(requesting_host)) {
                        oktoproceed = true
                        break
                    }
                }
                if (oktoproceed) {
                    LOG.info("requesting host ($requesting_host) is in the allowed host list request will be honored.")
                } else {
                    // Return an error
                    LOG.info("requesting host ($requesting_host) is NOT in the allowed host list request will be rejected.")
                    return Response.status(Response.Status.FORBIDDEN).type(MediaType.TEXT_PLAIN_TYPE)
                        .entity("You are not permitted to use this build server.").build()
                }
            } else {
                LOG.info("requiredHosts is not set, no restriction on callback url.")
            }
            asyncBuildRequests.incrementAndGet()
            if (gitBuildVersion != null && !gitBuildVersion.isEmpty()) {
                if (!gitBuildVersion.equals(GitBuildId.getVersion())) {
                    // This build server is not compatible with the App Inventor instance. Log this as severe
                    // so the owner of the build server will know about it.
                    val errorMessage =
                        "Build server version ${GitBuildId.getVersion()} is not compatible with App Inventor version $gitBuildVersion."
                    LOG.severe(errorMessage)
                    // This request was rejected because the gitBuildVersion parameter did not equal the
                    // expected value.
                    rejectedAsyncBuildRequests.incrementAndGet()
                    cleanUp()
                    // Here, we use CONFLICT (response code 409), which means (according to rfc2616, section
                    // 10) "The request could not be completed due to a conflict with the current state of the
                    // resource."
                    return Response.status(Response.Status.CONFLICT).type(MediaType.TEXT_PLAIN_TYPE)
                        .entity(errorMessage).build()
                }
            }
            val buildTask: Runnable = object : Runnable() {
                @Override
                fun run() {
                    val count: Int = buildCount.incrementAndGet()
                    try {
                        LOG.info("START NEW BUILD $count")
                        checkMemory()
                        buildAndCreateZip(userName, inputZipFile, isAab, ProgressReporter(callbackUrlStr))
                        // Send zip back to the callbackUrl
                        LOG.info("CallbackURL: $callbackUrlStr")
                        val callbackUrl = URL(callbackUrlStr)
                        val connection: HttpURLConnection = callbackUrl.openConnection() as HttpURLConnection
                        connection.setDoOutput(true)
                        connection.setRequestMethod("POST")
                        // Make sure we aren't misinterpreted as
                        // form-url-encoded
                        connection.addRequestProperty("Content-Type", "application/zip; charset=utf-8")
                        connection.setConnectTimeout(60000)
                        connection.setReadTimeout(60000)
                        val bufferedOutputStream = BufferedOutputStream(connection.getOutputStream())
                        try {
                            val bufferedInputStream = BufferedInputStream(
                                FileInputStream(outputZip)
                            )
                            try {
                                ByteStreams.copy(bufferedInputStream, bufferedOutputStream)
                                checkMemory()
                                bufferedOutputStream.flush()
                            } finally {
                                bufferedInputStream.close()
                            }
                        } finally {
                            bufferedOutputStream.close()
                        }
                        if (connection.getResponseCode() !== HttpURLConnection.HTTP_OK) {
                            LOG.severe("Bad Response Code!: " + connection.getResponseCode())
                            // TODO(user) Maybe do some retries
                        }
                    } catch (e: Exception) {
                        // TODO(user): Maybe send a failure callback
                        LOG.severe("Exception: ${e.getMessage()} and the length is of inputZip is ${inputZip.length()}")
                    } finally {
                        cleanUp()
                        checkMemory()
                        LOG.info("BUILD $count FINISHED")
                    }
                }
            }
            try {
                buildExecutor!!.execute(buildTask)
            } catch (e: RejectedExecutionException) {
                // This request was rejected because all threads in the build
                // executor are busy.
                rejectedAsyncBuildRequests.incrementAndGet()
                cleanUp()
                // Here, we use SERVICE_UNAVAILABLE (response code 503), which
                // means (according to rfc2616, section 10) "The server is
                // currently unable to handle the request due to a temporary
                // overloading or maintenance of the server. The implication
                // is that this is a temporary condition which will be
                // alleviated after some delay."
                return Response.status(Response.Status.SERVICE_UNAVAILABLE).type(MediaType.TEXT_PLAIN_TYPE)
                    .entity("The build server is currently at maximum capacity.").build()
            }
        }
        // Note: The code below should no longer be invoked. Progress reports
        // are now handled via a callback mechanism. The "50" here is just a plug
        // number.
        return Response.ok().type(MediaType.TEXT_PLAIN_TYPE)
            .entity("" + 0).build()
    }

    @Throws(IOException::class, JSONException::class)
    private fun buildAndCreateZip(userName: String, inputZipFile: File, isAab: Boolean, reporter: ProgressReporter?) {
        val buildResult: Result = build(userName, inputZipFile, isAab, reporter)
        val buildSucceeded: Boolean = buildResult.succeeded()
        outputZip = File.createTempFile(inputZipFile.getName(), ".zip")
        outputZip.deleteOnExit() // In case build server is killed before cleanUp executes.
        val zipOutputStream = ZipOutputStream(BufferedOutputStream(FileOutputStream(outputZip)))
        if (buildSucceeded) {
            if (outputKeystore != null) {
                zipOutputStream.putNextEntry(ZipEntry(outputKeystore.getName()))
                Files.copy(outputKeystore, zipOutputStream)
            }
            zipOutputStream.putNextEntry(ZipEntry(outputApk.getName()))
            Files.copy(outputApk, zipOutputStream)
            successfulBuildRequests.getAndIncrement()
        } else {
            LOG.severe("Build ${buildCount.get()} Failed: ${buildResult.getResult()} ${buildResult.getError()}")
            failedBuildRequests.getAndIncrement()
        }
        zipOutputStream.putNextEntry(ZipEntry("build.out"))
        val buildOutputJson = genBuildOutput(buildResult)
        val zipPrintStream = PrintStream(zipOutputStream)
        zipPrintStream.print(buildOutputJson)
        zipPrintStream.flush()
        zipOutputStream.flush()
        zipOutputStream.close()
    }

    @Throws(JSONException::class)
    private fun genBuildOutput(buildResult: Result): String {
        val buildOutputJsonObj = JSONObject()
        buildOutputJsonObj.put("result", buildResult.getResult())
        buildOutputJsonObj.put("error", buildResult.getError())
        buildOutputJsonObj.put("output", buildResult.getOutput())
        if (buildResult.getFormName() != null) {
            buildOutputJsonObj.put("formName", buildResult.getFormName())
        }
        return buildOutputJsonObj.toString()
    }

    @Throws(IOException::class)
    private fun build(userName: String, zipFile: File?, isAab: Boolean, reporter: ProgressReporter?): Result {
        outputDir = Files.createTempDir()
        // We call outputDir.deleteOnExit() here, in case build server is killed before cleanUp
        // executes. However, it is likely that the directory won't be empty and therefore, won't
        // actually be deleted. That's only if the build server is killed (via ctrl+c) while a build
        // is happening, so we should be careful about that.
        outputDir.deleteOnExit()
        val buildResult: Result = projectBuilder.build(
            userName,
            ZipFile(zipFile),
            outputDir,
            null,
            false,
            false,
            false,
            null,
            commandLineOptions.childProcessRamMb,
            commandLineOptions.dexCacheDir,
            reporter,
            isAab
        )
        val buildOutput: String = buildResult.getOutput()
        LOG.info("Build output: $buildOutput")
        val buildError: String = buildResult.getError()
        LOG.info("Build error output: $buildError")
        outputApk = projectBuilder.getOutputApk()
        if (outputApk != null) {
            outputApk.deleteOnExit() // In case build server is killed before cleanUp executes.
        }
        outputKeystore = projectBuilder.getOutputKeystore()
        if (outputKeystore != null) {
            outputKeystore.deleteOnExit() // In case build server is killed before cleanUp executes.
        }
        checkMemory()
        return buildResult
    }

    private fun cleanUp() {
        if (inputZip != null) {
            inputZip.delete()
        }
        if (outputKeystore != null) {
            outputKeystore.delete()
        }
        if (outputApk != null) {
            outputApk.delete()
        }
        if (outputZip != null) {
            outputZip.delete()
        }
        if (outputDir != null) {
            outputDir.delete()
        }
    }

    private class DeleteFileOnCloseFileInputStream(val file: File) : FileInputStream(file) {
        @Throws(IOException::class)
        override fun close() {
            super.close()
            file.delete()
        }
    }

    // Only do this scheme if we are not unlimited
    // (unlimited == 0) and allow more then 10 max builds
    private val shutdownState: ShutdownState
        private get() {
            if (turningOnTime != 0L && System.currentTimeMillis() > turningOnTime && turningOnTime > shuttingTime) {
                turningOnTime = 0
                shuttingTime = 0
            }
            return if (shuttingTime == 0L) {
                val max: Int = buildExecutor.getMaxActiveTasks()
                if (max < 10) {           // Only do this scheme if we are not unlimited
                    // (unlimited == 0) and allow more then 10 max builds
                    return ShutdownState.UP
                }
                val active: Int = buildExecutor!!.getActiveTaskCount()
                if (draining) {
                    if (active < max / 3) {
                        draining = false
                    }
                } else {
                    if (active > max * 2 / 3) {
                        draining = true
                    }
                }
                if (draining) {
                    ShutdownState.DRAINING
                } else {
                    ShutdownState.UP
                }
            } else if (turningOnTime >= System.currentTimeMillis()) {
                ShutdownState.TURNING
            } else if (shuttingTime >= System.currentTimeMillis()) {
                ShutdownState.SHUTTING
            } else {
                ShutdownState.DOWN
            }
        }

    companion object {
        private val commandLineOptions = CommandLineOptions()

        // Logging support
        private val LOG: Logger = Logger.getLogger(BuildServer::class.java.getName())
        private val APK_MEDIA_TYPE: MediaType = MediaType(
            "application",
            "vnd.android.package-archive",
            ImmutableMap.of("charset", "utf-8")
        )
        private val ZIP_MEDIA_TYPE: MediaType = MediaType(
            "application",
            "zip",
            ImmutableMap.of("charset", "utf-8")
        )
        private val buildCount: AtomicInteger = AtomicInteger(0)

        // The number of build requests for this server run
        private val asyncBuildRequests: AtomicInteger = AtomicInteger(0)

        // The number of rejected build requests for this server run
        private val rejectedAsyncBuildRequests: AtomicInteger = AtomicInteger(0)

        //The number of successful build requests for this server run
        private val successfulBuildRequests: AtomicInteger = AtomicInteger(0)

        //The number of failed build requests for this server run
        private val failedBuildRequests: AtomicInteger = AtomicInteger(0)

        //The number of failed build requests for this server run
        private var maximumActiveBuildTasks = 0

        // The build executor used to limit the number of simultaneous builds.
        // NOTE(lizlooney) - the buildExecutor must be created after the command line options are
        // processed in main(). If it is created here, the number of simultaneous builds will always be
        // the default value, even if the --maxSimultaneousBuilds option is on the command line.
        private var buildExecutor: NonQueuingExecutor? = null

        // non-zero means we are shutting down, if currentTimeMillis is > then this, then we are
        // completely shutdown, otherwise we are just providing NOT OK for health checks but
        // otherwise still accepting jobs. This avoids having people get an error if the load
        // balancer sends a job our way because it hasn't decided we are down.
        @Volatile
        private var shuttingTime: Long = 0

        @Volatile
        private var turningOnTime: Long = 0
        private val shutdownToken: String? = null

        @Volatile
        private var draining = false // We have exceeded 2/3 max load, waiting for
        private fun checkMemory() {
            val mBean: MemoryMXBean = ManagementFactory.getMemoryMXBean()
            mBean.gc()
            LOG.info("Build $buildCount current used memory: ${mBean.getHeapMemoryUsage().getUsed()} bytes")
        }

        @Throws(IOException::class)
        @JvmStatic
        fun main(args: Array<String>) {
            // TODO(markf): Eventually we'll figure out how to appropriately start and stop the server when
            // it's run in a production environment.   For now, just kill the process
            val cmdLineParser = CmdLineParser(commandLineOptions)
            try {
                cmdLineParser.parseArgument(args)
            } catch (e: CmdLineException) {
                LOG.severe(e.getMessage())
                cmdLineParser.printUsage(System.err)
                System.exit(1)
            }

            // Add a Shutdown Hook. In a container swarm, the swarm orchestrator
            // may choose to shutdown a container (running a buildserver) as part
            // of load balancing and other maintenance tasks. It will send a
            // SIGTERM signal to the container which will send it to us. This
            // shutdown hook causes us to wait until all build tasks are completed
            // before we exit, ensuring that people's build jobs are not interrupted
            // We combine this code with a configuration in the swarm service to *not*
            // hard kill a container for a period of time (say 15 minutes) to give
            // running jobs a chance to finish.
            Runtime.getRuntime().addShutdownHook(object : Thread() {
                @Override
                fun run() {
                    shuttingTime = System.currentTimeMillis()
                    if (buildExecutor == null) {
                        /* We haven't really started up yet... */
                        return
                    }
                    while (true) {
                        val tasks: Int = buildExecutor.getActiveTaskCount()
                        if (tasks <= 0) {
                            try {
                                Thread.sleep(10000) // One final wait so people can get
                                // their barcode
                            } catch (e: InterruptedException) {
                            }
                            return
                        }
                        try {
                            Thread.sleep(1000) // Wait one second and try again
                        } catch (e: InterruptedException) {
                            // XXX
                        }
                    }
                }
            })


            // Now that the command line options have been processed, we can create the buildExecutor.
            buildExecutor = NonQueuingExecutor(commandLineOptions.maxSimultaneousBuilds)
            val port = commandLineOptions.port
            val threadSelector: SelectorThread = GrizzlyServerFactory.create("http://localhost:$port/")
            val hostAddress: String = InetAddress.getLocalHost().getHostAddress()
            LOG.info("App Inventor Build Server - Version: ${GitBuildId.getVersion()}")
            LOG.info("App Inventor Build Server - Git Fingerprint: ${GitBuildId.getFingerprint()}")
            LOG.info("Running at: http://$hostAddress:$port/buildserver")
            if (commandLineOptions.maxSimultaneousBuilds == 0) {
                LOG.info("Maximum simultanous builds = unlimited!")
            } else {
                LOG.info("Maximum simultanous builds = ${commandLineOptions.maxSimultaneousBuilds}")
            }
            LOG.info("Visit: http://$hostAddress:$port/buildserver/health for server health")
            LOG.info("Visit: http://$hostAddress:$port/buildserver/vars for server values")
            LOG.info("Server running")
        }
    }
}